<!DOCTYPE html>
<html>
<head>
	
	<meta charset="UTF-8" />
	
	<title>
        
	Metrics | Bridging Systems

    </title>
	
    <meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- JS -->
	<script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
	<script>
		window.MathJax = {
			tex: {
				inlineMath: [['$', '$'], ['\\(', '\\)']],
				displayMath: [['$$', '$$'], ['\\[', '\\]']]
			},
			svg: {
				fontCache: 'global'
			}
		};
	</script>
	<script type="text/javascript" id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
	<script src="/js/lib/neverland.js"></script>
	<script src="/js/lib/markdown-it.js"></script>
	
	

	

	

	    



	<!-- Styling -->
	<script src="https://kit.fontawesome.com/52e6b7f776.js" crossorigin="anonymous"></script>
	<link rel="stylesheet" href="/css/main.css">

	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

</head>

<body class="post">

	<div>

	<div class="banner">
		This site is a work-in-progress and has not yet launched. All content is provisional.
	</div>

	<header>

		<a href="/" class="logotype">
			<div class="icon"><i class="fa-solid fa-bridge-suspension"></i></div>
			<div class="type">Bridging Systems</div>
		</a>

		<div class="outlinks">
			<a href="https://github.com/luke-thorburn/bridging-systems" target="_blank">
				<div class="icon"><i class="fa-brands fa-github"></i></div>
			</a>			
		</div>
		
		<nav>
			
				<a href="/../">Home</a>
			
				<a href="/paper/">Paper</a>
			
				<a href="/metrics/">Metrics</a>
			
				<a href="/working-group/">Working Group</a>
			
		</nav>
	</header>

	<main>

		<aside>
			
	<nav class="table-of-contents"><ol><li><a href="#table-of-metrics">Table of Metrics</a></li><li><a href="#notation">Notation</a></li><li><a href="#future-work">Future Work</a></li></ol></nav>

		</aside>

		

	


	<article>
		
		<h1 class="title">Metrics</h1>

		<h2 class="description"></h2>
	
		
			<p>This page contains a comprehensive review of metrics that have been proposed to quantify the degree of division or “polarization” in the public sphere.</p>
<ul>
<li>The metrics are designed to summarize an abstract model of the public sphere, which we assume is either a graph (e.g. a network of Twitter followers) or a set of points in Euclidean space (e.g. user embeddings on a social media platform).</li>
<li>Graph-based models can be converted into space-based models using graph embeddings. Space-based models can be converted into graph-based models using techniques from topological data analysis.</li>
<li>The semantics and provenance of the underlying model matter just as much as the metrics that are applied “on top”.</li>
<li>Not yet making any strong claims about which are most valid. Many of these should not be used for optimization.</li>
</ul>
<h1 id="table-of-metrics">Table of Metrics</h1>
<p>Use the <code>Esc</code> key to toggle full screen.</p>
<div class="outer-wrap" id="table-of-metrics">
	<button onclick="document.querySelector('html').classList.toggle('fullscreen')">
		<span class="expand"><i class="fas fa-expand-wide"></i>&ensp;View Fullscreen</span>
		<span class="compress"><i class="fas fa-compress-wide"></i>&ensp;Exit</span>
	</button>
	<div class="inner-wrap"></div>
</div>
<h1 id="notation">Notation</h1>
<h1 id="future-work">Future Work</h1>
<script>

	let md = window.markdownit();

	document.onkeydown = function(evt) {
		evt = evt || window.event;
		let isEscape = false;
		if ("key" in evt) {
			isEscape = (evt.key === "Escape" || evt.key === "Esc");
		}
		if (isEscape) {
			document.querySelector('html').classList.toggle('fullscreen');
		}
	};

	const {neverland: Component, render, html, useState, useEffect} = window.neverland;

	let columnSpecs = [
		{
			key: 'metric',
			label: 'Metric',
			minWidth: 200
		},
		{
			key: 'intuition',
			label: 'Intuition',
			minWidth: 300
		},
		{
			key: 'scope',
			label: 'Scope',
			minWidth: 140,
			type: 'data',
			filter: true,
			values: [
				'individual',
				'group',
				'population'
			],
			transform: value => {
				switch (value) {
					case "individual":
						return html`<i class="far fa-user"></i> individual`;
					case "group":
						return html`<i class="far fa-users"></i> sub-group`;
					case "population":
						return html`<i class="far fa-globe-asia"></i> population`;
					default:
						return '';
				}
			},
			filters: {},
		},
		{
			key: 'modelType',
			label: 'Model Type',
			minWidth: 160,
			type: 'data',
			filter: true,
			values: [
				'graph',
				'space'
			],
			filters: {},
			transform: value => {
				return value == "graph"
						? html`<i class="far fa-chart-network"></i> graph`
						: (value == "space" 
							? html`<i class="far fa-chart-scatter"></i> space`
							: value
				  		  )
			}
		},
		{
			key: 'requiredStructure',
			label: 'Structure Needed',
			minWidth: 250,
			type: 'tags',
			filter: true,
			values: [
				'groups',
				'signed edges'
			],
			filters: {},
			transform: value => {
				if (value == undefined) {
					return '';
				} else {
					let strs = value.split(', ');
					return strs.map(s => html`<div>${s}</div>`);
				}
			}
		},
		// {
		// 	key: 'concept',
		// 	label: 'Concept',
		// 	minWidth: 150,
		// 	filter: true,
		// 	values: [],
		// 	filters: {}
		// },
		{
			key: 'formula',
			label: 'Formula',
			transform: value => {
				return html`<span>${value}</span>`;
			}
		},
		{
			key: 'limitations',
			label: 'Limitations',
			minWidth: 400,
			transform: value => {
				if (typeof(value) == "string") {
					return { html: md.render(value) };
				} else {
					return '';
				}
			}
		},
		{
			key: 'references',
			label: 'References',
			minWidth: 200,
			transform: value => {
				if (typeof(value) == "string") {
					return { html: md.render(value) };
				} else {
					return '';
				}
			}
		},
	]

	const Row = Component(function(m, columns, setColumns) {

		return html.for(m)`<tr onclick="${() => {
			setColumns(prevColumns => {
				let columns = [...prevColumns];
				columns.forEach(c => {
					c.showFilters = false;
				})
				return columns;
			})
		}}">

			${columns.map((c, idx) => {
				return html`
					<td class="${c.type ? c.type : ''}">
						${c.transform
							? c.transform(m[c.key])
							: m[c.key]
						}
					</td>
				`;
			})}
			
		</tr>`;

	})

	const Table = Component(function() {

		let [metrics, setMetrics] = useState([]);
		let [sort, setSort] = useState({
			key: false,
			direction: -1
		});

		useEffect(() => {

			fetch('/data/metrics.json')
				.then(response => response.json())
				.then(data => {
					setMetrics(data);
				})

		}, []);

		let [columns, setColumns] = useState(columnSpecs);

		useEffect(() => {

			setColumns(prevColumns => {
				let columns = [...prevColumns];
				columns = columns.map(c => {
					if (c.filter) {
						if (c.type == "tags") {
							let tags = [];
							metrics.forEach(m => {
								tags = tags.concat((m[c.key] == undefined ? '' : m[c.key]).split(','));
							})
							c.values = Array(...(new Set(tags))).filter(d => Boolean(d)).sort();
						} else {
							c.values = Array(...(new Set(metrics.map(m => m[c.key])))).filter(d => Boolean(d)).sort();
						}
						if (metrics.map(m => m[c.key]).filter(d => d == undefined).length > 0) {
							c.values = c.values.concat(['NONE']);
						}

						c.filters = {};
						for (let v of c.values) {
							c.filters[v] = true;
						}
					}
					return c;
				})
				return columns;
			})

		}, [JSON.stringify(metrics)])

		useEffect(() => {
			if (MathJax.typeset) {
				MathJax.typeset();
			}
		}, [JSON.stringify(columns), sort.key, sort.direction])

		return html`<table class="metrics-table">

			<thead>
				<tr>
					${columns.map(c => {
						return html`<th style="${c.minWidth ? `min-width: ${c.minWidth}px;` : ''}">
							<div>
								<div class="label">${c.label}</div>
								<div class="actions">
									<button
										onclick="${() => {
											setSort(prevSort => {
												let sort = {...prevSort};
												sort.direction = (sort.key == c.key) ? -1*sort.direction : 1;
												sort.key = c.key;
												return sort;
											})
										}}"
										class="${sort.key == c.key ? 'active' : ''}"
										>
											${sort.key != c.key
												? html`<i class="fas fa-sort"></i>`
												: (sort.direction == 1
													? html`<i class="fad fa-sort-up"></i>`
													: html`<i class="fad fa-sort-down"></i>`)}
										</button>
									
									${c.filter
										? html`<button
											onclick="${() => {
												setColumns(prevColumns => {
													let columns = [...prevColumns];
													columns = columns.map(d => {
														if (d.key == c.key) {
															d.showFilters = !Boolean(d.showFilters);
														}
														return d;
													})
													return columns;
												})
											}}"
											class="${(c.showFilters | Object.values(c.filters).filter(d => !d).length > 0) ? 'active' : ''}"
											><i class="fas fa-filter"></i></button>` : ''}
									
									${c.filter ? html`<div class="filters ${c.showFilters ? '' : 'hide'}">
										${c.values.map(d => html`<div>
											<input
												type="checkbox"
												id="${c.key}-${d}"
												name="${c.key}-${d}"
												checked="${c.filters[d]}"
												onchange="${() => {
													setColumns(prevColumns => {
														let columns = [...prevColumns];
														columns = columns.map(col => {
															if (col.key == c.key) {
																col.filters[d] = !col.filters[d];
															}
															return col;
														})
														return columns;
													})
												}}">
											<label for="${c.key}-${d}">${d}</label>
										</div>`)}
									</div>` : ''}
								
								</div>
							</div>
						</th>`;
					})}
				</tr>
			</thead>

			<tbody>

				${JSON.parse(JSON.stringify(metrics))
					.filter(m => {
						let included = true;
						columns.filter(c => c.filter).forEach(c => {
							if (c.type == 'tags') {
								let tags = (m[c.key] == undefined ? 'NONE' : m[c.key]).split(', '),
									hasTag = false;
								tags.forEach(t => {
									hasTag = hasTag | c.filters[t];
								})
								included = included & hasTag;
							} else {
								included = included & c.filters[m[c.key] == undefined ? 'NONE' : m[c.key]];
							}
						})
						return included;
					})
					.sort((a, b) => {
						if (sort.key) {
							return sort.direction * ( 2*Number(a[sort.key] > b[sort.key]) - 1 );
						} else {
							return 1;
						}
					})
					.map(m => Row(m, columns, setColumns))}

			</tbody>

		</table>`;

	});

	render(document.querySelector('.inner-wrap'), Table());

</script>
		

	</article>


	
	<div class="backmatter">

		

		<section>
			
		</section>

		
		
		<section>
			<h1>License</h1>
			<p>This website and its content is made available under the <a href="https://github.com/luke-thorburn/bridging-systems/blob/main/LICENSE">MIT License</a>.</p>
		</section>

		

	</div>
	




	
	</main>	

	</div>

	<script type="module">
		// window.addEventListener('load', function () {
		// 	let root = document.documentElement;
		// 	root.style.setProperty('--header-height', document.querySelector('header').offsetHeight + "px");
		// })

		// Add 'active' class to the relevant link in the header.
		let links = document.querySelectorAll('header nav a');
		for (let k = 0; k < links.length; k++) {
			if (links[k].href == `${window.location.origin}${window.location.pathname}`) {
				links[k].classList.add('active');
			}
		}

	</script>

</body>

</html>